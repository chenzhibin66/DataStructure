排序算法

![](http://ww1.sinaimg.cn/large/005WjvZYly1g1ppxeoz4wj30s20bf3z4.jpg)

1.冒泡排序

冒泡排序的算法： 
1、比较相邻的元素，如果前一个比后一个大，就把它们交换位置 
2、对每一对相邻元素作相同的操作，从开始的一对到结束的一对，最后的元素就是最大的数 
3、针对所有的元素作相同的工作，除了最后一个

4、持续每次对越来越少的元素进行如上操作，直到没有一对数字需要比较  

java代码实现：

```java
import java.util.Arrays;

/**
 * 冒泡排序
 */
public class bubbling {
    public static void main(String[] args) {
        int[] a = new int[]{5, 8, 12, 1, 22, 10};
        int[] newArr = bullingSort(a);
        System.out.println(Arrays.toString(newArr));
    }

    public static int[] bullingSort(int[] a) {
        int len = a.length;
        for (int i = 0; i < len - 1; i++) {
            for (int j = i + 1; j < len - 1; j++) {
                if (a[i] > a[j]) {
                    int temp = a[i];
                    a[i] = a[j];
                    a[j] = temp;
                }
            }
        }
        return a;
    }
}
```

2.选择排序

初始时在序列中找到最小（最大）元素，放在序列的初始位置作为已排序序列，然后再从剩余未排序序列中找最小（最大）元素，放在已排序序列的末尾，一直持续，直到所有元素排序完毕 

```java
/**
 * 选择排序
 */

import java.util.Arrays;

public class select {
    public static void main(String[] args) {
        int[] a = new int[]{5, 8, 12, 1, 22, 10};
        int[] newArr = selectSort(a);
        System.out.println(Arrays.toString(newArr));
    }

    private static int[] selectSort(int[] a) {
        int len = a.length;
        for (int i = 0; i < len - 1; i++) {
            int k = i;
            for (int j = k + 1; j < len; j++) {
                if (a[j] < a[k]) {
                    k = j;  //找到最小值所在的位置
                }
            }
            if (i != k) {
                int temp = a[i];
                a[i] = a[k];
                a[k] = temp;
            }
        }
        return a;
    }
}
```

3.插入排序

具体算法： 
（1）从第一个元素开始，该元素可以认为已经被排序 
（2）取出下一个元素，在已经排序的元素序列中从后向前扫描 
（3）如果该元素大于新元素，将该元素移到下一位置 
（4）重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 
（5）将新元素插在该位置之后 

（6）重复步骤2-5

java代码：

```java
/**
 * 插入排序
 */
public class insert {
    public static void main(String[] args) {
        int[] a = new int[]{5, 8, 12, 1, 22, 10};
        int[] newArr = insertSort(a);
        System.out.println(Arrays.toString(newArr));
    }

    private static int[] insertSort(int[] a) {
        for (int i = 1; i < a.length; i++) {
            int target = a[i];
            int j = i - 1;
            while (j >= 0 && a[j] > target) {
                a[j + 1] = a[j];
                j--;
            }
            a[j + 1] = target;
        }
        return a;
    }
}
```

4.希尔排序

现在有一个array,希尔排序就是设定一个增量(0<h<array.length)

先从array[0]开始，以h为增量的进行直接插入排序，直到数组末尾，然后从array[1]开始重复：以h为增量的进行直接插入排序; 然后从array[1]开始重复......一直到array[n]。

然后取一个小于上一步增量的新的增量（比如设置为h/2）,对前一个步骤的结果array进行遍历，直接插入排序....

再取小于上一步增量的新的增量，重复进行：遍历，直接插入排序

直到新的增量小于1之后再退出循环

java代码：

```java
/**
 * 希尔排序
 */

import java.util.Arrays;

public class shell {
    public static void main(String[] args) {
        int[] a = new int[]{5, 8, 12, 1, 22, 10};
        int[] newArr = shellSort(a);
        System.out.println(Arrays.toString(newArr));
    }

    public static int[] shellSort(int[] a) {
        int h = a.length / 2;

        while (h >= 1) {
            for (int i = 0; i < a.length; i++) {
                for (int j = i; j < a.length - h; j += h) {
                    if (a[j] > a[j + h]) {
                        int temp = a[j];
                        a[j] = a[j + h];
                        a[j + h] = temp;
                    }
                }
            }
            h = h / 2;
        }

        return a;
    }
}

```